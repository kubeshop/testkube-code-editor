// src/index.ts
import { Emitter, languages as languages3 } from "monaco-editor/esm/vs/editor/editor.api.js";

// src/constants.ts
var languageId = "yaml";

// src/yamlMode.ts
import * as monaco from "monaco-editor/esm/vs/editor/editor.api.js";
import { registerMarkerDataProvider } from "monaco-marker-data-provider";
import { createWorkerManager } from "monaco-worker-manager";

// src/languageFeatures.ts
import {
  languages,
  MarkerSeverity,
  MarkerTag,
  Range,
  Uri
} from "monaco-editor/esm/vs/editor/editor.api.js";
import * as ls from "vscode-languageserver-types";
function toSeverity(lsSeverity) {
  switch (lsSeverity) {
    case ls.DiagnosticSeverity.Error:
      return MarkerSeverity.Error;
    case ls.DiagnosticSeverity.Warning:
      return MarkerSeverity.Warning;
    case ls.DiagnosticSeverity.Hint:
      return MarkerSeverity.Hint;
    default:
      return MarkerSeverity.Info;
  }
}
function toMarkerDataTag(tag) {
  return tag === ls.DiagnosticTag.Deprecated ? MarkerTag.Deprecated : MarkerTag.Unnecessary;
}
function toDiagnostics(diag) {
  var _a;
  return {
    severity: toSeverity(diag.severity),
    startLineNumber: diag.range.start.line + 1,
    startColumn: diag.range.start.character + 1,
    endLineNumber: diag.range.end.line + 1,
    endColumn: diag.range.end.character + 1,
    message: diag.message,
    code: String(diag.code),
    source: diag.source,
    tags: (_a = diag.tags) == null ? void 0 : _a.map(toMarkerDataTag)
  };
}
function createMarkerDataProvider(getWorker) {
  return {
    owner: languageId,
    async provideMarkerData(model) {
      const worker = await getWorker(model.uri);
      const diagnostics = await worker.doValidation(String(model.uri));
      return diagnostics == null ? void 0 : diagnostics.map(toDiagnostics);
    },
    async doReset(model) {
      const worker = await getWorker(model.uri);
      await worker.resetSchema(String(model.uri));
    }
  };
}
function fromPosition(position) {
  return { character: position.column - 1, line: position.lineNumber - 1 };
}
function toRange(range) {
  return new Range(
    range.start.line + 1,
    range.start.character + 1,
    range.end.line + 1,
    range.end.character + 1
  );
}
function fromRange(range) {
  return {
    start: { line: range.startLineNumber - 1, character: range.startColumn - 1 },
    end: { line: range.endLineNumber - 1, character: range.endColumn - 1 }
  };
}
function fromMarkerData(marker) {
  return {
    message: marker.message,
    range: fromRange(marker),
    code: typeof marker.code === "object" ? marker.code.value : marker.code,
    source: marker.source
  };
}
function toCompletionItemKind(kind) {
  const mItemKind = languages.CompletionItemKind;
  switch (kind) {
    case ls.CompletionItemKind.Text:
      return mItemKind.Text;
    case ls.CompletionItemKind.Method:
      return mItemKind.Method;
    case ls.CompletionItemKind.Function:
      return mItemKind.Function;
    case ls.CompletionItemKind.Constructor:
      return mItemKind.Constructor;
    case ls.CompletionItemKind.Field:
      return mItemKind.Field;
    case ls.CompletionItemKind.Variable:
      return mItemKind.Variable;
    case ls.CompletionItemKind.Class:
      return mItemKind.Class;
    case ls.CompletionItemKind.Interface:
      return mItemKind.Interface;
    case ls.CompletionItemKind.Module:
      return mItemKind.Module;
    case ls.CompletionItemKind.Property:
      return mItemKind.Property;
    case ls.CompletionItemKind.Unit:
      return mItemKind.Unit;
    case ls.CompletionItemKind.Value:
      return mItemKind.Value;
    case ls.CompletionItemKind.Enum:
      return mItemKind.Enum;
    case ls.CompletionItemKind.Keyword:
      return mItemKind.Keyword;
    case ls.CompletionItemKind.Snippet:
      return mItemKind.Snippet;
    case ls.CompletionItemKind.Color:
      return mItemKind.Color;
    case ls.CompletionItemKind.File:
      return mItemKind.File;
    case ls.CompletionItemKind.Reference:
      return mItemKind.Reference;
    default:
      return mItemKind.Property;
  }
}
function toTextEdit(textEdit) {
  return {
    range: toRange(textEdit.range),
    text: textEdit.newText
  };
}
function createCompletionItemProvider(getWorker) {
  return {
    triggerCharacters: [" ", ":"],
    async provideCompletionItems(model, position) {
      const resource = model.uri;
      const worker = await getWorker(resource);
      const info = await worker.doComplete(String(resource), fromPosition(position));
      if (!info) {
        return;
      }
      const wordInfo = model.getWordUntilPosition(position);
      const wordRange = new Range(
        position.lineNumber,
        wordInfo.startColumn,
        position.lineNumber,
        wordInfo.endColumn
      );
      const items = info.items.map((entry) => {
        var _a;
        const item = {
          label: entry.label,
          insertText: (_a = entry.insertText) != null ? _a : entry.label,
          sortText: entry.sortText,
          filterText: entry.filterText,
          documentation: entry.documentation,
          detail: entry.detail,
          kind: toCompletionItemKind(entry.kind),
          range: wordRange
        };
        if (entry.textEdit) {
          item.range = toRange(
            "range" in entry.textEdit ? entry.textEdit.range : entry.textEdit.replace
          );
          item.insertText = entry.textEdit.newText;
        }
        if (entry.additionalTextEdits) {
          item.additionalTextEdits = entry.additionalTextEdits.map(toTextEdit);
        }
        if (entry.insertTextFormat === ls.InsertTextFormat.Snippet) {
          item.insertTextRules = languages.CompletionItemInsertTextRule.InsertAsSnippet;
        }
        return item;
      });
      return {
        incomplete: info.isIncomplete,
        suggestions: items
      };
    }
  };
}
function toLocationLink(locationLink) {
  return {
    originSelectionRange: locationLink.originSelectionRange && toRange(locationLink.originSelectionRange),
    range: toRange(locationLink.targetRange),
    targetSelectionRange: toRange(locationLink.targetSelectionRange),
    uri: Uri.parse(locationLink.targetUri)
  };
}
function createDefinitionProvider(getWorker) {
  return {
    async provideDefinition(model, position) {
      const resource = model.uri;
      const worker = await getWorker(resource);
      const definitions = await worker.doDefinition(String(resource), fromPosition(position));
      return definitions == null ? void 0 : definitions.map(toLocationLink);
    }
  };
}
function createHoverProvider(getWorker) {
  return {
    async provideHover(model, position) {
      const resource = model.uri;
      const worker = await getWorker(resource);
      const info = await worker.doHover(String(resource), fromPosition(position));
      if (!info) {
        return;
      }
      return {
        range: info.range && toRange(info.range),
        contents: [{ value: info.contents.value }]
      };
    }
  };
}
function toSymbolKind(kind) {
  const mKind = languages.SymbolKind;
  switch (kind) {
    case ls.SymbolKind.File:
      return mKind.Array;
    case ls.SymbolKind.Module:
      return mKind.Module;
    case ls.SymbolKind.Namespace:
      return mKind.Namespace;
    case ls.SymbolKind.Package:
      return mKind.Package;
    case ls.SymbolKind.Class:
      return mKind.Class;
    case ls.SymbolKind.Method:
      return mKind.Method;
    case ls.SymbolKind.Property:
      return mKind.Property;
    case ls.SymbolKind.Field:
      return mKind.Field;
    case ls.SymbolKind.Constructor:
      return mKind.Constructor;
    case ls.SymbolKind.Enum:
      return mKind.Enum;
    case ls.SymbolKind.Interface:
      return mKind.Interface;
    case ls.SymbolKind.Function:
      return mKind.Function;
    case ls.SymbolKind.Variable:
      return mKind.Variable;
    case ls.SymbolKind.Constant:
      return mKind.Constant;
    case ls.SymbolKind.String:
      return mKind.String;
    case ls.SymbolKind.Number:
      return mKind.Number;
    case ls.SymbolKind.Boolean:
      return mKind.Boolean;
    case ls.SymbolKind.Array:
      return mKind.Array;
    default:
      return mKind.Function;
  }
}
function toDocumentSymbol(item) {
  var _a, _b;
  return {
    detail: (_a = item.detail) != null ? _a : "",
    range: toRange(item.range),
    name: item.name,
    kind: toSymbolKind(item.kind),
    selectionRange: toRange(item.selectionRange),
    children: (_b = item.children) == null ? void 0 : _b.map(toDocumentSymbol),
    tags: []
  };
}
function createDocumentSymbolProvider(getWorker) {
  return {
    async provideDocumentSymbols(model) {
      const resource = model.uri;
      const worker = await getWorker(resource);
      const items = await worker.findDocumentSymbols(String(resource));
      if (!items) {
        return;
      }
      return items.map(toDocumentSymbol);
    }
  };
}
function createDocumentFormattingEditProvider(getWorker) {
  return {
    async provideDocumentFormattingEdits(model) {
      const resource = model.uri;
      const worker = await getWorker(resource);
      const edits = await worker.format(String(resource), {});
      if (!edits || edits.length === 0) {
        return;
      }
      return edits.map(toTextEdit);
    }
  };
}
function toLink(link) {
  return {
    range: toRange(link.range),
    tooltip: link.tooltip,
    url: link.target
  };
}
function createLinkProvider(getWorker) {
  return {
    async provideLinks(model) {
      const resource = model.uri;
      const worker = await getWorker(resource);
      const links = await worker.findLinks(String(resource));
      if (!links) {
        return;
      }
      return {
        links: links.map(toLink)
      };
    }
  };
}
function toWorkspaceEdit(edit) {
  const edits = [];
  if (edit.changes) {
    for (const [uri, textEdits] of Object.entries(edit.changes)) {
      for (const textEdit of textEdits) {
        const monacoEdit = {
          text: textEdit.newText,
          range: toRange(textEdit.range)
        };
        edits.push({
          resource: Uri.parse(uri),
          versionId: void 0,
          textEdit: monacoEdit,
          // @ts-expect-error This is for compatibility with monaco-editor<0.34
          edit: monacoEdit
        });
      }
    }
  }
  return {
    edits
  };
}
function toCodeAction(codeAction) {
  var _a, _b;
  return {
    title: codeAction.title,
    diagnostics: (_a = codeAction.diagnostics) == null ? void 0 : _a.map(toDiagnostics),
    disabled: (_b = codeAction.disabled) == null ? void 0 : _b.reason,
    edit: codeAction.edit ? toWorkspaceEdit(codeAction.edit) : void 0,
    kind: codeAction.kind,
    isPreferred: codeAction.isPreferred
  };
}
function createCodeActionProvider(getWorker) {
  return {
    async provideCodeActions(model, range, context) {
      const resource = model.uri;
      const worker = await getWorker(resource);
      const codeActions = await worker.getCodeAction(
        String(resource),
        fromRange(range),
        context.markers.map(fromMarkerData)
      );
      if (!codeActions) {
        return;
      }
      return {
        actions: codeActions.map(toCodeAction),
        dispose() {
        }
      };
    }
  };
}

// src/yamlMode.ts
var richEditConfiguration = {
  comments: {
    lineComment: "#"
  },
  brackets: [
    ["{", "}"],
    ["[", "]"],
    ["(", ")"]
  ],
  autoClosingPairs: [
    { open: "{", close: "}" },
    { open: "[", close: "]" },
    { open: "(", close: ")" },
    { open: '"', close: '"' },
    { open: "'", close: "'" }
  ],
  surroundingPairs: [
    { open: "{", close: "}" },
    { open: "[", close: "]" },
    { open: "(", close: ")" },
    { open: '"', close: '"' },
    { open: "'", close: "'" }
  ],
  onEnterRules: [
    {
      beforeText: /:\s*$/,
      action: { indentAction: monaco.languages.IndentAction.Indent }
    }
  ]
};
function setupMode(defaults) {
  const worker = createWorkerManager(monaco, {
    label: "yaml",
    moduleId: "monaco-yaml/yaml.worker",
    createData: {
      languageSettings: defaults.diagnosticsOptions,
      enableSchemaRequest: defaults.diagnosticsOptions.enableSchemaRequest
    }
  });
  defaults.onDidChange(() => {
    worker.updateCreateData({
      languageSettings: defaults.diagnosticsOptions,
      enableSchemaRequest: defaults.diagnosticsOptions.enableSchemaRequest
    });
  });
  monaco.languages.registerCompletionItemProvider(
    languageId,
    createCompletionItemProvider(worker.getWorker)
  );
  monaco.languages.registerHoverProvider(languageId, createHoverProvider(worker.getWorker));
  monaco.languages.registerDefinitionProvider(
    languageId,
    createDefinitionProvider(worker.getWorker)
  );
  monaco.languages.registerDocumentSymbolProvider(
    languageId,
    createDocumentSymbolProvider(worker.getWorker)
  );
  monaco.languages.registerDocumentFormattingEditProvider(
    languageId,
    createDocumentFormattingEditProvider(worker.getWorker)
  );
  monaco.languages.registerLinkProvider(languageId, createLinkProvider(worker.getWorker));
  monaco.languages.registerCodeActionProvider(
    languageId,
    createCodeActionProvider(worker.getWorker)
  );
  monaco.languages.setLanguageConfiguration(languageId, richEditConfiguration);
  let markerDataProvider = registerMarkerDataProvider(
    monaco,
    languageId,
    createMarkerDataProvider(worker.getWorker)
  );
  defaults.onDidChange(() => {
    markerDataProvider.dispose();
    markerDataProvider = registerMarkerDataProvider(
      monaco,
      languageId,
      createMarkerDataProvider(worker.getWorker)
    );
  });
}

// src/index.ts
var diagnosticDefault = {
  completion: true,
  customTags: [],
  enableSchemaRequest: false,
  format: true,
  isKubernetes: false,
  hover: true,
  schemas: [],
  validate: true,
  yamlVersion: "1.2"
};
function createLanguageServiceDefaults(initialDiagnosticsOptions) {
  const onDidChange = new Emitter();
  let diagnosticsOptions = initialDiagnosticsOptions;
  const languageServiceDefaults = {
    get onDidChange() {
      return onDidChange.event;
    },
    get diagnosticsOptions() {
      return diagnosticsOptions;
    },
    setDiagnosticsOptions(options) {
      diagnosticsOptions = { ...diagnosticDefault, ...options };
      onDidChange.fire(languageServiceDefaults);
    }
  };
  return languageServiceDefaults;
}
var yamlDefaults = createLanguageServiceDefaults(diagnosticDefault);
languages3.register({
  id: languageId,
  extensions: [".yaml", ".yml"],
  aliases: ["YAML", "yaml", "YML", "yml"],
  mimetypes: ["application/x-yaml"]
});
languages3.onLanguage("yaml", () => {
  setupMode(yamlDefaults);
});
function setDiagnosticsOptions(options = {}) {
  yamlDefaults.setDiagnosticsOptions(options);
}
export {
  createLanguageServiceDefaults,
  setDiagnosticsOptions,
  yamlDefaults
};
//# sourceMappingURL=index.js.map
